---
title: Redis面试汇总
categories: 
    - Redis
tags:
    - Redis
    - 面试
keywords: 
    - Redis
    - 面试
cover: https://cdn.jsdelivr.net/gh/CrazyDuck827/CrazyDuck827.github.io/icon/RPAIEAjwLkmZR1fayU9gQD3xEJzoBhJ3.jpg
---

### 基础
#### 5种数据类型
- String字符串
    场景：计数，缓存，分布式锁
        
- Hash哈希
    场景：存储对象，例如保存用户的一些属性信息，用户的详情页
        
- List列表
    场景：队列，关注列表，粉丝列表
        
- Set集合
    场景：交集，差集，并集，如共同关注、共同喜好、二度好友等功能
        
- ZSet（SortedSet）有序集合
    原理：内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率
    场景：排行耪

### 持久化
#### 作用
    redis重启后的数据恢复，是保证数据恢复的措施

#### 策略
##### RDB
- 定义：在指定的时间间隔能对你的数据进行快照存储
- 优点：
   - 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了
   - 相比于AOF机制，如果数据集很大，RDB的启动效率会更高
- 缺点：
   - 不能最大限度的避免数据丢失。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失
   - 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟
- 触发机制：
   - save（同步）：客户端向Redis发送save命令来创建一个快照文件
        执行save命令的时候，如果存在老的快照文件，新的将会替换老的。
        
   - bgsave（异步）：：客户端向Redis发送bgsave命令，Redis调用fork创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求
   
   - 自动：通过配置，满足任何一个条件就会创建快照文件
   ```
       save 90 1(90s发生1次写入)
       save 30 10(30s发生10次写入)
       save 60 1000(60s发生1000次写入)
   ```

##### AOF
- 定义：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据
- 优点：
   - 该机制可以带来更高的数据安全性
   - 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容
   - 如果日志过大，Redis可以自动启用rewrite机制
   - AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作
- 缺点：
   - AOF日志文件通常比RDB数据快照文件更大
   - 数据恢复时效率较慢
- 运行机制：
>Append-Only File，将“操作 + 数据”以格式化指令的方式追加到操作日志文件的尾部，在 append 操作返回后(已经 写入到文件或者将要写入)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程；当 server 需要数据 恢复时，可以直接 replay 此日志文件，即可还原所有的操作过程。AOF 相对可靠，AOF 文件内容是字符串，非常 容易阅读和解析。

- 开启：AOF 默认关闭，开启方法，修改配置文件 reds.conf：appendonly yes
- 同步策略
   - always：每一条 aof 记录都立即同步到文件，这是最安全的方式，也以为更多的磁盘操作和阻塞延迟，是 IO 开支 较大。
   - everysec：每秒同步一次，性能和安全都比较中庸的方式，也是 redis 推荐的方式。如果遇到物理服务器故障，有 可能导致最近一秒内 aof 记录丢失(可能为部分丢失)，默认
   - no：redis 并不直接调用文件同步，而是交给操作系统来处理，操作系统可以根据 buffer 填充情况 / 通道空闲时间 等择机触发同步；这是一种普通的文件操作方式。性能较好，在物理服务器故障时，数据丢失量会因 OS 配置有关

##### 区别
- aof文件比rdb更新频率高，优先使用aof还原数据
- aof比rdb更安全也更大
- rdb性能比aof好
- 如果两个都配了优先加载aof
- RDB优点：使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
- RDB缺点：RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候
- AOF优点：可以保持更高的数据完整性，如果设置追加 file 的时间很短，比如1s，如果 redis 发生故障，最多会丢失 1s 的数据
- AOF缺点：AOF 文件比 RDB 文件大，且恢复速度慢

### 分布式锁
- 加锁方式：incr、set、setnx、hSetnx等
- 以set为例
   - 加锁：设置一个有时效性的key
   - 解锁：不能直接删除，场景是用户2获取的锁，有可能会被用户1删除。
   - 解锁方案：lua脚本解锁，lua执行具有原子性，注意：用 lua 脚本 php.ini 需要开放 shell_exec() 等系统函数
   - lua脚本
      - 判断锁是否存在
      - 如果不存在，则加一个有时效性的锁
      - **ARGV[1]**代表的就是锁key的默认生存时间，默认30秒
      - **ARGV[2]**代表的是加锁的客户端的ID
- 问题
   - redis分布式锁过期时间到了，业务没执行完
        watch dog（看门狗）自动延期机制
        只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间
        业务的机器万一宕机，锁过期之后就解开了

### 架构
#### 主从复制
- slaveof
- 复制原理
   - Redis的复制功能是基于内存快照的持久化策略基础上的，也就是说无论你的持久化策略选择的是什么，只要用到了Redis的复制功能，就一定会有内存快照发生。
   - 当Slave启动并连接到Master之后，它将主动发送一个SYNC命令( 首先Master会启动一个后台进程，将数据快照保存到文件中[rdb文件] Master 会给Slave 发送一个Ping命令来判断Slave的存活状态 当存活时 Master会将数据文件发送给Slave 并将所有写命令发送到Slave )
   - Slave首先会将数据文件保存到本地 之后再将 数据 加载到内存中。
   - 当第一次链接 或者是 故障后 重新连接 都会先判断Slave的存活状态 在做全部数据的同步  ， 之后只会同步Master的写操作(将命令发送给Slave)
- 问题
   - 当  Master 同步数据时 若数据量较大 而Master本身只会启用一个后台进程 来对多个Slave进行同步 ， 这样Master就会压力过大 ， 而且Slave 恢复的时间也会很慢！
- 优点
   - 在一个Redis集群中，master负责写请求，slave负责读请求，这么做一方面通过将读请求分散到其他机器从而大大减少了master服务器的压力，另一方面slave专注于提供读服务从而提高了响应和读取速度
   - 在一个Redis集群中，如果master宕机，slave可以介入并取代master的位置，因此对于整个Redis服务来说不至于提供不了服务，这样使得整个Redis服务足够安全
   - 水平增加Slave机器可以提高性能
   
#### 读写分离
#### 哨兵
#### 集群

### 常见问题
#### 缓存雪崩
- 原因：当缓存服务器重启或者大量缓存集中在某一个时间段失效，给服务器造成压力，引起DB压力过大甚至导致DB宕机
- 解决方案
   - 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
   - 某个key只允许一个线程查询数据和写缓存，其他线程等待
   - 分布式部署
   - 异步进程更新缓存
   
#### 缓存穿透
- 原因：故意请求redis和DB都不存在的key，给服务器造成压力，引起DB压力过大甚至导致DB宕机
- 解决方案
   - 过滤输入
        对一定不存在的key进行过滤
   - 缓存空值
        对查询结果为空的情况也进行缓存
   - 布隆过滤器
        将所有可能存在的数据哈 希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力
   - 接口限流与熔断、降级
        重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。

#### 缓存击穿
- 原因：某个热点数据失效时，大量针对这个数据的请求会穿透到数据源（与雪崩的区别是：雪崩是大面积的，击穿是针对热点数据小面积的）
- 解决方案
   - 设置热点数据永远不过期，有更新操作就更新缓存
   - 互斥锁，保证同一个进程中针对同一个数据不会并发请求到 DB
   - 使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新

#### 避免出现以上问题的总结
- 事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
- 事中：本地 ehcache 缓存 + Hystrix 限流+降级，避免MySQL被打死。
- 事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

#### 缓存和数据库双写一致性问题
- 原因：当更新（update或delete）操作发生时，导致的数据不一致的问题；同时更新redis和更新数据库的原子性无法得到满足，不论是先更新数据库还是redis都有可能失败，并且高并发下还随时伴有顺序未知的读取操作
- 解决：利用消息队列来实现消息最终一致性的保证，并且还需要利用消息队列的重试机制来保证能够更新成功，如果多次消费失败，可能是由于网络或者redis挂了

### 布隆过滤器
    利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return

### 事务
    watch，multi，exec
    
### 管道
### 异步队列
    list，pub/sub主题订阅者模式
    
### 与memcached的主要区别
1. 存储
   - redis：内存+磁盘
   - memcache：内存
2. 数据结构
   - redis：多种
   - memcache：键值对
3. 线程
   - redis：单线程
        单线程的原因有两个：
        1. 采用了非阻塞的异步事件处理机制
        2. 缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价
   - memcache：多线程
4. 持久化
   - redis：支持
   - memcache：不支持

-----

### 面试问题

#### 为什么使用redis？
> 因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 Redis 和 Memcached 不过中和考虑了他们的优缺点，最后选择了Redis
> 注意：Redis 和 Memcached 的对比各自的优缺点和应用场景

#### 如果有大量的key需要设置同一时间过期，一般需要注意什么？
> 结果：Redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩
> 解决：
> 1. 在时间上加一个随机值，使得过期时间分散一些
> 2. 定时任务刷新缓存

#### Redis分布式锁？
> 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放
> 用set指令可以同时把setnx和expire合成一条指令来用的

#### 在巨大的数据量的情况下，做类似于查找符合某种规则的Key的信息？
> 1. 【keys】命令：由于Redis单线程这一特性，keys命令是以阻塞的方式执行的，线上服务会停顿，直到指令执行完毕
> 2. 【scan】命令：以非阻塞的方式实现key值的查找，但是会有一定的重复概率，在客户端做一次去重就可以了

#### Redis做异步队列？
> 1. 一般使用list结构作为队列，【rpush】生产消息，【lpop】消费消息。当lpop没有消息的时候，要适当sleep一会再重试
> 2. 不使用sleep的话可以使用【blpop】指令，在没有消息的时候，它会阻塞住直到消息到来

#### 能不能生产一次消费多次呢？
> 1. 使用【pub/sub】主题订阅者模式，可以实现 1:N 的消息队列。
> 2. 缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如【RocketMQ】等。

#### Redis如何实现延时队列？
> 使用【sortedset】，拿时间戳作为score，消息内容作为key调用【zadd】来生产消息，消费者用【zrangebyscore】指令获取N秒之前的数据轮询进行处理

#### Redis是怎么持久化的？服务主从数据怎么交互的？
> RDB做镜像全量持久化，AOF做增量持久化.因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。
> Redis机制是：AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功；AOF/RDB文件存在错误时，Redis启动失败并打印错误信息

#### 如果在持久化过程中突然机器掉电会怎样？
> 取决于AOF日志sync(同步)属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

#### RDB的原理是什么？
> fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来

#### Pipeline有什么好处，为什么要用pipeline？
> 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

#### Redis的同步机制？
> Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

#### 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？
> Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
> Redis Cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

#### Redis 为什么早期版本选择单线程？
> 使用单线程模型能带来更好的 可维护性，方便开发和调试
> 使用单线程模型也能 并发 的处理客户端的请求；(I/O 多路复用机制)
> Redis 服务中运行的绝大多数操作的 性能瓶颈都不是 CPU；

#### Redis 为什么这么快？
> 1. 纯内存操作：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)
> 2. 单线程，无锁竞争：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；
> 3. 多路 I/O 复用模型，非阻塞 I/O：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；
> 4. 高效的数据结构，加上底层做了大量优化：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..








