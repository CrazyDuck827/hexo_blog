---
title: MySQL面试汇总
categories: 
    - MySQL
tags:
    - MySQL
    - 面试
keywords: 
    - MySQL
    - 面试
cover: https://cdn.jsdelivr.net/gh/CrazyDuck827/CrazyDuck827.github.io/icon/RPAIEAjwLkmZR1fayU9gQD3xEJzoBhJ3.jpg
---

### 基础
#### 基本命令
    create database <数据库名>
    drop database <数据库名>
    create table <表名>
    drop table <表名>
    INSERT INTO <表名> (列1, 列2,...) VALUES (值1, 值2,....)
    delete from 表名 where 表达式
    update 表名 set 字段=新值,… where 条件
    select <字段1，字段2，...> from < 表名 > where < 表达式 >

#### SQL语言分类
    查询语言DQL，控制语言DCL，操纵语言DML，定义语言DDL
    
- DQL：可以简单理解为SELECT语句
- DCL：GRANT、ROLLBACK和COMMIT一类语句
- DML：可以理解为CREATE一类的语句
- DDL：INSERT、UPDATE和DELETE语句都是

#### 三范式
    第一范式：属性不可分割
    第二范式：每个数据表必须拥有主键，并且唯一标识整个数据表
    第三范式：消除数据冗余，信息只在一个数据表存储，不能存储在多张数据表。然后通过外键进行关联
#### 存储引擎
##### 分类
- InnoDB
   - 支持行锁，事务
   - InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁，也就是说，InnoDB的行锁是基于索引的
- MyISAM

##### InnoDB和MyISAM的主要区别
- 储存方式
   - InnoDB：表空间数据文件和它的日志文件
   - MyISAM：每个MyISAM在磁盘上存储成三个文件
      - 第一个文件的名字以表的名字开始，扩展名指出文件类型，.frm文件存储表定义
      - 第二个文件是数据文件，其扩展名为.MYD (MYData)
      - 第三个文件是索引文件，其扩展名是.MYI (MYIndex)
- 外键
   - MyISAM不支持，InnoDB支持
- 事务
   - MyISAM不支持，InnoDB支持
- 锁
   - MyISAM表锁
   - InnoDB表锁，行锁

### 索引
#### 定义
    是一种数据结构
    加快数据库的检索速度
    会降低插入、删除、修改等维护任务的速度
    需要占物理和数据空间

#### 最左匹配原则
##### 定义
- MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配
- 所以索引列的排列顺序决定了可命中索引的列数
- =、in自动优化顺序（按索引排序）不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列

##### 解析
- 因此，列的排列顺序决定了可命中索引的列数
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找
- 索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即联合索引

#### 索引分类
- 从数据结构角度
   - B+树索引
   - hash索引
      - 本质上就是把键值换算成新的哈希值，根据这个哈希值来定位
      - 优点
            检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快
      - 缺点
            没办法利用索引完成排序
            不支持模糊查询以及多列索引的最左匹配原则
            hash索引任何时候都避免不了回表查询数据
            不支持范围查询;因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致
            在有大量重复键值情况下，哈希索引的效率也是极低的---->哈希碰撞问题
   - FULLTEXT索引
   - R-Tree索引

- 从物理存储角度
   - 聚集索引
      - 定义
            数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引
      - 特点
            叶子节点存的是整行数据
            查询效率要比非聚集索引的效率高
   - 非聚集索引
      - 定义
            该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引
      - 特点
            叶子节点内容是主键的值，有二次查询问题

- 从逻辑角度
   - 主键索引
   - 普通索引(单列索引)
   - 多列索引（复合索引）
      - 创建
            key(a,b,c)
      - 生效原则
            从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用
   - 唯一索引或者非唯一索引
   - 空间索引

#### 索引失效
- 查询条件中有or
- like查询是以'%'开头
- 对查询的列上有运算或者函数的
- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
- is null， is not null
- 全表扫描比索引快，则不使用索引

#### 优化
- 选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少

### 事务
#### 四大特性（ACID）
   - 原子性(Atomicity)：指的是事务要么完全执行,要么完全不执行
   - 一致性(Consistency)：事务完成时,数据必须处于一致的状态
   - 隔离性(Isolation)：同时处理多个事务时,一个事务的执行不能被另一个事务所干扰,事务的内部操作与其他并发事务隔离
   - 持久性(Durability)：事务提交后,对数据的修改是永久性的
   
#### 分类
- 隐式事务
    没有开启和结束的标志，默认执行完SQL语句就自动提交，比如我们经常使用的INSERT、UPDATE、DELETE语句就属于隐式事务
- 显式事务
    需要显示的开启关闭，然后执行一系列操作，最后如果全部操作都成功执行，则提交事务释放连接，如果操作有异常，则回滚事务中的所有操作

#### MVCC（多版本并发控制机制）
- 基本原理
   - 通过保存数据在某个时间点的快照实现
   - 每行数据都存在一个版本，每次数据更新时都更新该版本
   - 修改时Copy出当前版本随意修改，各个事务之间无干扰
   - 保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）
   - 可以认为它就是乐观锁的一种实现方式
   
- 基本实现
   - 在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号
   - 每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较
   - 插入操作：记录的版本号即当前事务的版本号
   - 更新操作：采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式
   - 删除操作：事务版本号作为删除版本号
   - 查询操作：在查询时要符合以下两个条件的记录才能被事务查询出来
      - 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除
      - 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中或者在当前事务启动之前的其他事物进行的插入

- 注意
    MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）
    > 因为Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC（原因是MVCC的创建版本和删除版本只要在事务提交后才会产生）
    > 串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题

#### 调优原则
- 结合业务场景，使用低级别事务隔离
- 避免行锁升级表锁
- 控制事务的大小，减少锁定的资源量和锁定时间长度

### 隔离级别
#### 定义
- 不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别
- 事务的隔离级别就是通过锁的机制来实现，只不过隐藏了加锁细节

#### 种类
- Read uncommitted(读未提交)：会出现脏读，不可重复读，幻读
- Read committed(读已提交)：会出现不可重复读，幻读
- Repeatable read(可重复读) - MySQL的默认事务隔离级别：会出现幻读(但在Mysql实现的Repeatable read配合gap锁或mvcc就不会出现幻读！)
- Serializable(可串行化)：串行，避免以上的情况！

#### 现象
- 脏读
   - 定义：一个事务读取到另外一个事务未提交的数据
   - 原因：因为在读的时候没有加读锁，导致可以读取出还没释放锁的记录
   - 解决：在读取的时候生成一个版本号，直到事务其他commit被修改了之后，才会有新的版本号
   
- 幻读
   - 指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致（幻读侧重于新增或者删除）
   
- 不可重复读
   - 一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改，即一个事务内多次查询的数据可能不同（不可重复读侧重于修改）
   
- 更新丢失
   - 一个事务的更新覆盖了另一个事务的更新

### 锁
#### 分类维度
- 加锁机制
   - 乐观锁
   - 悲观锁
- 锁粒度
   - 表锁：开销小，加锁快，粒度大，锁冲突概率大，并发度低，适用于读多写少的情况。
   - 页锁：BDB存储引擎
   - 行锁：Innodb存储引擎，默认选项，注意，innoDB中行级锁是加在索引上的，因此只有命中索引的情况才会是行级锁，不然是表级锁
- 兼容性
   - 共享锁
   - 排他锁
- 锁模式
   - 记录锁
   - gap锁
   - next-key锁
   - 意向锁
   - 插入意向锁

- 表锁
   - 表读锁
   - 表写锁
   - 意向锁（InnoDB，隐式添加）
      - 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁，事务想要获得一张表中某几行的共享锁
      - 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁，事务想要获得一张表中某几行的排他锁
   
- 行锁
   - 共享锁，S锁，读锁：读锁是共享的，多个客户可以同时读取同一个资源，但不允许其他客户修改
   - 排他锁，X锁，写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁

#### 概念
- 乐观锁
   - 定义：表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新
   - 实现：
      - task表有三个字段，分别是id，value，version
      - 每次更新task表中的value字段时，为了防止发生冲突，需要判断版本号
      - update task set value = newValue,version =  versionValue + 1   where version = versionValue;
      
- 悲观锁
   - select * from xxxx for update
   - 在select 语句后边加了 for update相当于加了排它锁(写锁)，加了写锁以后，其他的事务就不能对它修改了！需要等待当前事务修改完之后才可以修改
   - 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性 set autocommit=0;
   
- 间隙锁
   - 定义：当我们用范围条件检索数据而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合范围条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁
   - 目的：
      - 为了防止幻读
      - 满足恢复和复制的需要（MySQL的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读）

#### 死锁
- 概念：两个事务在执行过程中因为争夺资源造成的一种互相等待的现象
- 解决：
   - 以固定的顺序访问表和行
   - 大事务拆小
   - 降低隔离级别
   - 为表添加合理的索引

### 主从
#### 定义：
   - 允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。一般是主服务器写，从服务器读
#### 操作：
   - 前提是作为主服务器角色的数据库服务器必须开启二进制日志并配置唯一的服务器ID（server_id）
   - 主服务器上面的任何修改都会通过自己的 I/O tread(I/O 线程)保存在二进制日志 Binary log 里面。
   - 从服务器上面也启动一个 I/O thread，通过配置好的用户名和密码, 连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log（中继日志）里面。
   - 从服务器上面同时开启一个 SQL thread 定时检查 Realy log(这个文件也是二进制的)，如果发现有更新立即把更新的内容在本机的数据库上面执行一遍。
   - 从服务器设备负责决定应该执行二进制日志中的哪些语句。
   - 使用 show slave status\G 检查是否成功
#### 线程
   - binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中
   - I/O 线程 ：负责从主服务器上读取- 二进制日志，并写入从服务器的中继日志（Relay log）
   - SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）
   
    读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

### 读写分离
#### 操作：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作
#### 提高性能的原因：
- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

    

#### 同步延迟
- 产生原因
    当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待
- 解决方案
   - 优化配置
   - 将二进制日志只给某一从，该从不记录只负责将二进制日志转发给其它从

### 数据备份
#### 导入
- 导出数据和表结构： mysqldump -u用户名 -p密码 数据库名 > 数据库名.sql
- 只导出表结构：mysqldump -u用户名 -p密码 -d 数据库名 > 数据库名.sql

#### 导出
- 方法一
    use abc
    set names utf8
    source /home/abc/abc.sql
    
- 方法二
    mysql -u用户名 -p密码 数据库名 < 数据库名.sql
     
### 调优
#### 性能调优

#### sql调优
##### 慢查询日志
##### explain
- 列字段
    id：select查询的序列号
    【select_type】：查询类型;常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY 子查询等。
    table：数据表
    【type】：访问类型，ALL、index、range、ref、eq_ref、const、system（从左到右，性能从差到好）
       - ALL：因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的
       - index：查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快，后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了
       - system: 表中只有一条数据. 这个类型是特殊的const类型
       - const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可
       - range: 表示使用索引范围查询
       
    【possible_keys】：该查询可以利用的索引，如果没有任何索引显示 null
    【Key】：MySQL实际决定使用的索引
    【key_len】：索引中使用的字节数，可通过该列计算查询中使用的索引的长度
    ref：哪些列或常量被用于查找索引列上的值
    【rows】：估算找到所需记录所需读取的行数
    【Extra】：额外信息
       - Using filesort：表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大
       - Using index："覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错
       - Using temporary：查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化

##### 查询优化
1. 创建索引
2. 缓存配置
   - query cache缓存查询数据
   - 把query_cache_size大小设置为非0。下次相同查询server就直接从缓存获取数据，而不是再执行查询。能缓存的数据量就和你的size大小设置有关，所以当你设置的足够大，数据可以完全缓存到内存，速度就会非常之快。
   - 当你对数据表做任何的更新操作(update/insert/delete)等操作，server为了保证缓存与数据库的一致性，会强制刷新缓存数据，导致缓存数据全部失效
3. slow_query_log（慢查询日志）
   - 当超过你设置的慢查询时间(long_query_time)的时候就把该条查询记录到日志
4. 分库分表

### 数据结构
- 二叉树（平衡树）
    它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
- AVL树
    它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况
- 红黑树
    每个节点非红即黑；根节点是黑的；每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；如果一个节点是红的,那么它的两儿子都是黑的；对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；每条路径都包含相同的黑节点
    通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍
- hash
- BTree（B-Tree）
    定义任意非叶子结点最多只有M个儿子，且M>2;根结点的儿子数为[2, M];除根结点以外的非叶子结点的儿子数为[M/2, M];每个结点存放至少M/2-1（取上整）和至多M-1个关键字（至少2个关键字） ;非叶子结点的关键字个数=指向儿子的指针个数-1;非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1];非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树;所有叶子结点位于同一层
- B+Tree
    非叶子节点的子树指针与关键字个数相同;非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复);为所有叶子节点增加一个链指针;所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的);非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层;更适合于文件系统

> 为什么说B+树比B树更适合数据库索引
> 1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小
> 2. B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当
> 3. 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引
> 4. B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低

-----

### 常见面试问题

#### 三大范式是什么？
> 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；
  第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；
  第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；

#### 数据库五大约束是什么？
> 1. primary KEY:设置主键约束；
  2. UNIQUE：设置唯一性约束，不能有重复值；
  3. DEFAULT 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2
  4. NOT NULL：设置非空约束，该字段不能为空；
  5. FOREIGN key :设置外键约束。

#### 怎么设置主键？
> 在定义列时设置：ID INT PRIMARY KEY
  在列定义完之后设置：primary KEY（id）

#### 主键约束和唯一约束的主要区别是什么？
> 1. 主键不能为null，唯一可以为null
  2. 主键是不可能（或很难）更新；唯一是可以更新 
  3. 定义主键时自动创建聚簇索引。相反，Unique键生成非聚集索引。
  4. 主健可作外健，唯一索引不可；

#### innodb和myisam有什么区别？
> 1. InnoDB支持事务，而MyISAM不支持事物，崩溃后无法安全恢复，表锁非常影响性能
> 2. InnoDB支持行级锁，而MyISAM支持表级锁
> 3. InnoDB支持MVCC，实现了四个标准的隔离级别 而MyISAM不支持
> 4. InnoDB 表是基于聚族索引建立的，聚族索引对主键查询有很高的性能
> 5. InnoDB支持外键，而MyISAM不支持
> 6. MyISAM擅长读，InnoDB擅长写

#### 索引的数据结构?
> 索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等
  InnoDB存储引擎的默认索引实现为:B+树索引

#### 常见的数据结构?
> 1. 搜索二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加，显然这个不适合作为大量数据存储的基础结构。
> 2. B树(m阶)：一棵m阶B树是一棵平衡的m路搜索树。
>    特点：
>    - 关键字集合分布在整颗树中；
>    - 任何一个关键字出现且只出现在一个节点中；
>    - 每个节点存储data和key；
>    - 搜索有可能在非叶子节点结束；
>    - 一个节点中的key从左到右非递减排列；
>    - 所有叶节点具有相同的深度，等于树高h。
> 3. B+树：
>    特点：
>    - 所有关键字都存储在叶子节上，且链表中的关键字是有序的；
>    - 不可能非叶子节点命中返回；
>    - 非叶子节点相当于叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层 带顺序访问指针的B+树提高了区间查找能力
> - B+树与B树区别：
>    - B+非叶子节点不存储data，只存储key
>    - 所有的关键字全部存储在叶子节点上
>    - 每个叶子节点含有一个指向相邻叶子节点的指针
>    - 非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字

#### innodb索引的实现原理是什么？
> InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上
> 若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据
> 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。

#### btree和hash类型的索引有什么不同？
> hash索引底层：hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据
> B+树底层实现：多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.
> 区别：
> - hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询；因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询
> - B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.
> - hash索引不支持使用索引进行排序,原理同上.
> - hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性.
> - hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.
> - hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差
> - B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.
>
> 因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.

#### 什么是覆盖索引？
> 简单的说，select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
  覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B-tree索引做覆盖索引。

#### 聚簇索引和非聚簇索引？
> 聚簇索引：按照每张表的主键构造一颗B+树，同时叶子节点中存放的key值以及整行的数据，也将聚集索引的叶子节点称为数据页
>    - 优点
>       1. 聚簇索引将索引和数据行保存在同一个B-Tree中，查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高。
>       2. 聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的，
>    - 缺点
>       1. 聚簇索引的更新代价比较高，如果更新了行的聚簇索引列，就需要将数据移动到相应的位置。这可能因为要插入的页已满而导致“页分裂”
>       2. 插入速度严重依赖于插入顺序，按照主键进行插入的速度是加载数据到Innodb中的最快方式。如果不是按照主键插入，最好在加载完成后使用OPTIMIZE TABLE命令重新组织一下表
>       3. 聚簇索引在插入新行和更新主键时，可能导致“页分裂”问题
>       4. 聚簇索引可能导致全表扫描速度变慢，因为可能需要加载物理上相隔较远的页到内存中（需要耗时的磁盘寻道操作）
>
> 非聚簇索引（又称二级索引或辅助索引）：叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找（回表查询）。
>
> 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.
> 当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.

#### 在建立索引的时候,都有哪些需要考虑的因素呢?
> 建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.

#### 导致索引失效的原因有哪些？

#### Explain 怎么用来做sql优化？

#### varchar和char有什么区别?
> 1. char的长度是不可变的，而varchar的长度是可变的 。
> 2. char的存取速度比varchar要快得多，因为其长度固定，方便程序的存储与查找；而varchar是以空间效率为首位的。
> 3. char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。

#### LEFT JOIN 、RIGHT JOIN、INNER JOIN 区别？
> LEFT JOIN(左连接)：获取左表所有记录，即使右表没有对应匹配的记录
  RIGHT JOIN(右连接)： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录
  INNER JOIN(内连接)：获取两个表中字段匹配关系的记录

#### UNION、UNION ALL区别？
> union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；
  union All：对两个结果集进行并集操作，包括重复行，不进行排序；

#### 常用的MySQL函数
> 1. 数学函数
>   floor(x) 返回不大于 x 的最大整数值
    ceil/ceiling(x) 返回不小于 x 的最小整数
    round(x) 四舍五入
    rand() 随机函数[0, 1)
    abs(x) 返回 x 的绝对值
>
> 2. 字符串函数
>   concat(str1, str2, ...) 将参数连接成字符串返回
    length(str) 返回字符串长度
>
> 3.加密函数
>   PASSWORD(str) 对字符串 str 进行加密
    MD5(str) 对字符串 str 进行加密
>
> 4.格式化函数
>   FORMAT(x, n) 可以将数字 x 进行格式化，保留到小数点后 n 位，四舍五入

#### 你的sql优化常用技巧有哪些？
> 使用参数化查询：防止SQL注入，预编译SQL命令提高效率
  去掉不必要的查询和搜索字段
  争取命中索引，或者根据已有的查询情景简历合理的索引
  不要使用select *：不要使用select *，以提高查询效率，减少输出的数据量，提高传输速度
  尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理
  减少访问数据库的次数，业务代码逻辑优化，避免for循环
  使用表的别名(Alias)：当在SQL语句中连接多个表时, 减少解析的时间，减少那些由Column歧义引起的语法错误
  使用列的别名：当列的名称很长的时候，使用简短的列的别名可以查询结果更清晰，更简洁
  状态，类型等字段使用tinyint类型
  字段设计not null：null值会占用更多的字节
  索引可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因此索引并非越多越好，合理有效的使用
  尽量避免大事务操作，提高系统并发能力

#### 什么是事务？事务的四大特性是什么

#### 事务的隔离级别和各自解决的问题是什么？
>脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
 不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
 幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".
>
> 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
  读提交：一个事务提交之后，它做的变更才会被其他事务看到。
  可重复读： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。(默认)
  串行化： 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

隔离级别	|脏读	|不可重复读|	幻读
:--|:--:|:--:|:--:
读未提交|	可能|	可能|	可能
读提交|	不可能	|可能|	可能
可重复读	|不可能|	不可能|	可能
串行化|	不可能	|不可能|	不可能

#### InnoDB怎么实现的事务ACID特性？
> - redo log重做日志用来保证事务的持久性
  - undo log回滚日志保证事务的原子性
  - undo log+redo log保证事务的一致性
  - 锁（共享、排他）用来保证事务的隔离性

#### InnoDB是如何保证隔离性的？
> 利用锁和 MVCC 机制

#### InnoDB的MVCC实现原理是什么？
> 在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号
> - SELECT
  InnoDB 会根据以下两个条件检查每行记录：
  InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
  行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
  只有符合上述两个条件的记录，才能返回作为查询结果。
>
> - INSERT
  InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
>
> - DELETE
  InnoDB为删除的每一行保存当前系统版本号作为行删除标识。
>
> - UPDATE
  InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
>
> 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。



-----
### sql编写题


![sql编写题1](https://cdn.jsdelivr.net/gh/CrazyDuck827/CrazyDuck827.github.io/image/b5998750715c629e4be7b44b9739a354_819x486.jpeg)












