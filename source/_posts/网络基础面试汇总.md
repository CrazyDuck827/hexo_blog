---
title: 网络基础面试汇总
categories: 
    - 网络基础
tags:
    - 网络基础
    - 面试
keywords: 
    - 网络基础
    - 面试
cover: https://cdn.jsdelivr.net/gh/CrazyDuck827/CrazyDuck827.github.io/icon/RPAIEAjwLkmZR1fayU9gQD3xEJzoBhJ3.jpg
---

### TCP/IP
#### 协议
- 四层（从下往上）
   - 应用层：定义数据格式，并按照对应的格式解读数据
   - 传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序
   - 网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发
   - 链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据

#### 三次握手、四次挥手


### UDP
    用户数据报协议，和TCP在同一传输层的，提供面向事务的简单不可靠信息传送服务
### DNS
    负责域名解析，提供域名到IP地址之间的解析服务
### HTTP/HTTPS
#### 状态码
- 1xx：指示信息 -- 表示请求已接收，继续处理
- 2xx：成功 -- 表示请求已被成功接收、理解、接受
    200 OK：表示从客户端发送给服务器的请求被正常处理并返回
    204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）
    206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容
- 3xx：重定向 -- 要完成请求必须进行更进一步的操作
    301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL
    302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL
    > 301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）
    
    303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源
    > 302与303的区别：后者明确表示客户端应当采用GET方式获取资源
    
    304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码
    307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET
- 4xx：客户端错误 -- 请求有语法错误或请求无法实现
    400 Bad Request：表示请求报文中存在语法错误
    401 Unauthorized：未经许可，需要通过HTTP认证
    403 Forbidden：服务器拒绝该次访问（访问权限出现问题）
    404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用
    
- 5xx：服务器端错误 -- 服务器未能实现合法的请求
    500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时
    502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应
    503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求
    504（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求

#### 请求方式
    get，post，put，patch，delete，head

### OAuth2
### cookie
### session

-----

### 面试常见问题
#### 简述 TCP 三次握手？
> 服务器进程先创建传输控制块 TCB，并处于监听状态，等待客户端的连接请求
  客户端创建传输控制块 TCB，并向服务器发出连接请求报文段
  服务器收到连接请求报文段后，如同意建立连接，则发送确认报文段
  客户端进程收到服务器的确认报文段后，立即回复确认报文段，并进入已建立连接状态
  服务器收到确认报文段之后，也进入已建立连接状态

#### 简述TCP 四次挥手？
> 客户端应用进程发出连接释放报文段，并停止再发送数据，进入 FIN-WAIT-1(终止等待1)状态，等待服务器确认
  服务器收到连接释放报文段后即发出确认，进入 CLOSE-WAIT(关闭等待)状态，服务器若发送数据，客户端扔要接收
  客户端收到来自服务器的确认后，进入 FIN-WAIT-2(终止等待2)状态，等待服务器发出连接释放报文段
  服务器没有要发送的数据，发出连接释放报文段，进入 LAST-ACK(最后确认)状态，等待客户端确认
  客户端收到连接释放报文段后，发出确认，进入 TIME-WAIT(时间等待)状态，经过时间等待计时器设置的时间 2MSL 后，进入 CLOSED(关闭) 状态
  服务器收到客户端报文段后，进入 CLOSED 状态

#### 为什么连接的时候是三次握手，关闭的时候却是四次握手？
> 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"，仅仅表示对方不再发送数据了但是还能接收数据。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

#### 为什么客户端最后在TIME_WAIT还要等待2MSL（最大报文存活时间）？
> 1. 保证服务器收到客户端的最后一个ACK，若这个ACK丢失，服务器会重发一次FIN+ACK，这时客户端还没有关闭连接，就能收到重发的请求并给出响应。同时重启2MSL计时器
> 2. 客户端发送完最后一个ACK后，本连接持续时间内的所有报文段都会从网络中消失，新的连接中就不会收到已经关闭的旧连接中的报文

#### 403可能出现的原因是什么，怎么解决？
> 1. 由于启动用户和nginx工作用户不一致所致
>       - 查看nginx的启动用户，发现是nobody，而为是用root启动的
>       命令：ps aux | grep "nginx: worker process" | awk'{print $1}'
>       - 将nginx.config的user改为和启动用户一致，
> 2. 缺少index.html或者index.php文件，就是配置文件中index index.html index.htm这行中的指定的文件
> 3. 权限问题，如果nginx没有web目录的操作权限，也会出现403错误
> 4. SELinux设置为开启状态（enabled）的原因

#### 500 一般是什么问题，如何解决？
> 1. 500 Internal Server Error 内部服务错误：顾名思义500错误一般是服务器遇到意外情况，而无法完成请求
> 2. 500出错的可能性：
>    - 编程语言语法错误，web脚本错误
>    - 并发高时，因为系统资源限制，而不能打开过多的文件
> 3. 一般解决思路
>    - 查看nginx、php的错误日志文件，从而看出端倪
>    - 如果是too many open files，修改nginx的worker_rlimit_nofile参数，使用ulimit查看系统打开文件限制，修改/etc/security/limits.conf，还是出现too many open files，那就要考虑做负载均衡，把流量分散到不同服务器上去了
>    - 如果是脚本的问题，则需要修复脚本错误，优化代码

#### 503出现一般是什么问题？
> 503是服务临时不可用
> 可能原因：nginx配置了频率限制，client端又超过了配置的限制，比如单个ip并发设置过小

#### nginx返回502，504各是什么问题，怎么解决？
> - 502 Bad Gateway:作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应
>    1. 什么是无法理解的响应
>       - nginx无法与php-fpm进行连接
>       - nginx在连接php-fpm一段时间后发现与php-fpm的连接被断开
>    2. 什么时候会出现
>       - php-fpm没有启动,nginx无法将请求交给php-fpm
>       - php-fpm运行脚本超时，php-fpm终止了脚本的执行和执行脚本的Worker进程，nginx发现自己与php-fpm的连接断开（php-fpm.conf中的max_terminate_request过小）
> - 504 Bad Gateway timeout:客户端所发出的请求没有到达网关,在限定时间内没有得到php-fpm，或者完成php-fpm的传输数据的工作而超时
>    1. 解决办法
>       ```
            location ~ \.php$ {
                    fastcgi_connect_timeout  180;//指定连接到后端 FastCGI 的超时时间.
                    fastcgi_read_timeout     600;//接收 FastCGI 应答的超时时间，这个值是指已经完成两次握手后接收FastCGI应答的超时时间.
                    fastcgi_send_timeout     600;//向 FastCGI 传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI传送请求的超时时间.
                    fastcgi\_pass unix:/tmp/php-fpm.sock;
                    fastcgi\_index index.php;
                    include fastcgi.conf;
                } 
        ```

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？
> 服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### http处于网络分层模型的哪一层？
> 应用层：http/ftp
> 传输层：tcp/udp
> 网络层：ip/arp
> 链路层

#### HTTP 请求头部信息有哪些？
> User-Agent :客户端信息
  Accept : 客户端希望接受的数据类型，比如 Accept：application/json
  Connection ： 表示是否需要持久连接，比如Keep-Alive
  Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
  Cookie：浏览器端cookie

#### HTTP 报文的组成是怎么样的？
> - 请求报文
>    1. 请求行
>       - 请求方法
>       - HTTP协议版本
>    2. 请求头
>    3. 空行
>    4. 请求体
> - 响应报文
>    1. 状态行
>       - 状态码
>    2. 响应头
>    3. 空行
>    4. 响应体

#### HTTP 2.0的特点有啥？
> 多路复用、客户端拉拽/服务器推送、流量控制、WebSocket

#### WebSocket是什么？
> WebSocket 是一种通信协议，定义了一个全双工通信信道，仅通过 Web 上的一个 Socket 即可进行通信
> 主要特点
> 推送功能：支持由服务器向客户端推送数据的推送功能
> 减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态

#### IPv6 与 IPv4 有什么变化？
> 更大的地址空间、扩展的地址层次结构、灵活的首部格式、改进的选项、允许协议继续扩充、支持资源的预分配

#### 什么是心跳机制？
> 心跳机制是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制

#### HTTP 2.0的特点有啥？
> 多路复用、客户端拉拽/服务器推送、流量控制、WebSocket

#### 怎么允许跨域访问？
> jsonp
> 服务端允许跨域，开启cors

#### 一个网页从输入地址回车，到完整展示网页内容这段时间里，做了哪些工作？
> 1. 浏览器本地缓存匹配；
> 2. 本地hosts映射对比;
> 3. 本地dns缓存解析；
> 4. 远程dns解析获得服务器ip地址；
> 5. 浏览器发送tcp连接请求包(syn)；
> 6. 请求包经过传输层、网络层、数据链路层封装通过网卡到达路由器；
> 7. 路由器转发数据包到所属运营商服务器；
> 8. 运营商服务器通过寻址最短路径通过中继节点到达指定ip地址；
> 9. 服务器端可能存在反向代理或者负载均衡，都是直接转发请求至上游服务器，当然也可以制定安全防御规则直接丢弃请求包；
> 10. 上游服务器收到连接请求，在自身可用的情况下，返回(syn+ack)；
> 11. 浏览器校验ack，再次发送(syn+ack)；
> 12. 服务器校验ack切换连接状态至established，然后根据请求传输数据包；
> 13. 当transform-encoding为chunked时，浏览器开始渲染页面；
> 14. 四次挥手，连接关闭；
> 15. 渲染数据完成。

#### http和https的区别是什么？
> https协议需要到CA（Certificate Authority）证书颁发机构申请证书，一般免费证书较少，因而需要一定费用。
  https在http学医的基础上增加了ssl安全层， 一系列认证流程是在ssl层完成的。
  http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
  http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

#### 客户端在使用HTTPS方式与Web服务器是怎么通信的？
> HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，数据传输阶段又可以分为非对称加密和对称加密两个阶段
> 1. 客户端请求服务器，服务器返回数字证书（里面包括，服务器公钥，网站地址，证书颁发机构），数字证书本身使用证书私钥加密
> 2. 解密证书，验证证书数字签名，通过操作系统和浏览器内置的CA证书信息。验证通过后，客户端生成一个随机密码，用接收到的服务器公钥将其加密，发送到服务器
> 3. 用服务器私钥解密，得到随机密码
> 4. 握手结束，之后的通信全部使用随机密码进行对称加密通信













